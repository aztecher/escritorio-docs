

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>05. Raspi GPIO Device Driver &mdash; SphinxRoot 1.0.0 ドキュメント</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="SphinxRoot 1.0.0 ドキュメント" href="../../../index.html"/>
        <link rel="up" title="Device Driver" href="index.html"/>
        <link rel="next" title="06. ioctl Implementation" href="06.ioctl_implementation.html"/>
        <link rel="prev" title="04. read/write and Memory" href="04.read_write_and_memory.html"/> 

  
  <script src="../../../static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> SphinxRoot
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../Haskell/index.html">Haskell Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Golang/index.html">Golang Documents</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">C Documents</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../BasicKnowledge/index.html">BasicKnowledge</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../GDB/index.html">GDB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../LLDB/index.html">LLDB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Library/index.html">Libraries</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">C MyProjects</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Device Driver</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="01.create_simple_kernel_module.html">01. Create Simple Kernel Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="02.driver_register_static.html">02. Driver Register (Static)</a></li>
<li class="toctree-l4"><a class="reference internal" href="03.driver_register_dynamic.html">03. Driver Register (Dynamic)</a></li>
<li class="toctree-l4"><a class="reference internal" href="04.read_write_and_memory.html">04. read/write and Memory</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">05. Raspi GPIO Device Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="06.ioctl_implementation.html">06. ioctl Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="07.interface_for_procfs.html">07. interface for procfs</a></li>
<li class="toctree-l4"><a class="reference internal" href="08.interface_for_debugfs.html">08. interface for debugfs</a></li>
<li class="toctree-l4"><a class="reference internal" href="09.call_other_kernel_module.html">09. call other kernel module</a></li>
<li class="toctree-l4"><a class="reference internal" href="10.i2c_device_driver.html">10.I2C Device Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="11.add_i2c_device_to_device_tree.html">11. Add I2C Device to DeviceTree</a></li>
<li class="toctree-l4"><a class="reference internal" href="12.bootloading_device_driver.html">12. bootloading device driver</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../Infrastructure/index.html">Infrastructure Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Micon/index.html">Micon Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Git/index.html">Git Documents</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">SphinxRoot</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">C Documents</a> &raquo;</li>
      
          <li><a href="../index.html">C MyProjects</a> &raquo;</li>
      
          <li><a href="index.html">Device Driver</a> &raquo;</li>
      
    <li>05. Raspi GPIO Device Driver</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../sources/C/MyProjects/DeviceDriver/05.raspi_gpio_device_driver.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="raspi-gpio-device-driver">
<h1>05. Raspi GPIO Device Driver<a class="headerlink" href="#raspi-gpio-device-driver" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>前回までで, デバドラの基本操作を行うシステムコールの実装方法を理解した.
今回はこれまでの内容を使って, ラズパイのGPIOデバドラを実装する.</p>
<p>しっかりとしてGPIOデバドラを作る目的ではないため, 簡単のために, 対象はGPIO4(4番ピン)のみで, 常にこのピンを出力モードとする. writeで, High/Lowをこのピンから出力する. 現在の出力レベルを&#8221;1&#8221;/&#8221;0&#8221;の文字列としてreadで確認できるようにする.</p>
<p>参考URL</p>
<ul class="simple">
<li><a class="reference external" href="https://qiita.com/take-iwiw/items/cd1d7734c8911830386d">組み込みLinuxデバイスドライバの作り方</a></li>
</ul>
<div class="section" id="id1">
<h2>前提知識<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id2">
<h3>メモリ空間に関して(再)<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">ここの話もしっかりと理解する. 今回行うような操作や手続きをリファレンスのみでできるようになると, ひとまず一人前だと思う.</p>
</div>
<p>前回説明を省略したが, 今回は必要なのでメモリのアドレス番号を取得する方法に関して記しておく.
とはいえ, 以下の画像で理解できるはずである. (相変わらず解像度問題があるので, 必要に応じてiPadを確認する)</p>
<img alt="../../../images/PeripheralAddress.jpg" src="../../../images/PeripheralAddress.jpg" />
<p>上記URLの筆者の環境ではラズパイ2で, CPUはBCM2835という番号であった. 私の手元にあるのは, ラズパイ3で, CPUはBCM2837であったがデータシートを確認したところ, おそらく2835と同じようであった. <cite>bcm_host_get_peripheral_address</cite> 関数で取得できる値も <cite>3F000000</cite> であったことと, <cite>cat /proc/cpuinfo | grep Hardware</cite> の値も <cite>2835</cite> とあったので, これは実質2835と考えていいだろう.</p>
<p>今回は簡単のために, ARM(CPU)からみたペリフェラルレジスタの物理アドレスは <cite>3F000000</cite> で固定とする.
そして, データシートを見ると, ペリフェラルのアドレスは <cite>7E000000</cite> であるため, それぞれのオフセットを計算して, <cite>3F000000</cite> に加えたアドレスが, 操作すべきハードウェアレジスタの値である.</p>
<p>以下に, 今回使用するレジスタについて記述する.</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="23%" />
<col width="11%" />
<col width="12%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">レジスタ名</th>
<th class="head">データシート上のアドレス</th>
<th class="head">オフセット</th>
<th class="head">物理アドレス</th>
<th class="head">何をするつもりか</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GPFSEL0 (GPIO Function Select 0)</td>
<td>0x7E200000</td>
<td>0x00200000</td>
<td>0x3F200000</td>
<td>出力モード設定するのに使う</td>
</tr>
<tr class="row-odd"><td>GPSET0 (GPIO Pin Output Set 0)</td>
<td>0x7E20001C</td>
<td>0x0020001C</td>
<td>0x3F20001C</td>
<td>High出力する</td>
</tr>
<tr class="row-even"><td>GPCLR0 (GPIO Pin Output Char 0)</td>
<td>0x7E200028</td>
<td>0x00200028</td>
<td>0x3F200028</td>
<td>Low出力する</td>
</tr>
<tr class="row-odd"><td>GPLEV0 (GPIO Pin Level 0)</td>
<td>0x7E200034</td>
<td>0x00200034</td>
<td>0x3F200034</td>
<td>現在の出力レベルを取得する</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id3">
<h3>ユーザ空間プログラムで試しに実装する<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これまで, カーネルモジュールを作ってきたが, レジスタアクセスだけならばユーザ空間からもできる. 今回はGPIO制御のレジスタを叩くだけなので, ひとまずユーザ空間上のプログラムで実装してみる. これでうまく動いたら, 後でカーネルモジュール側でデバイスドライバの実装に取り掛かる. 事前にユーザ空間で試すことで, デバッグがやりやすい利点がある.</p>
<p>ユーザ空間から行うために, ユーザ空間プログラムから物理アドレスに対してアクセスする必要がある. まず, <cite>/dev/mem</cite> をopenする. そしてそのファイルディスクリプタを使用して <cite>mmap</cite> する. この時, オフセットとして物理アドレスを指定する. サイズは使用する分だけでも良いが, <a class="reference internal" href="#id11">ページ</a> サイズ(4KByte)確保している例が多いようである. なお, openするときに <cite>O_SYNC</cite> を指定する. これによりキャッシュが無効になり, 即レジスタアクセスが行われる (そもそも, レジスタではキャッシュが使われない設定のはずだがねんのための処理)</p>
<p>言葉ではわかりにくいので下図を参照するといい.</p>
<img alt="../../../images/RegisterAddressFromUserSpace.jpg" src="../../../images/RegisterAddressFromUserSpace.jpg" />
<p>ここで取り上げられているコードでは, それぞれ必要なオフセット値と, ペリフェラルレジスタの物理アドレスの開始位置などがdefineされており, オフセット等からアドレスを計算する場合にはシフト演算(&lt;&lt;)を利用している
これに関しては, データシートをよく読まないとわからないだろう. 下の画像は今回のレジスタ操作の概要を示している.</p>
<img alt="../../../images/Register0.jpg" src="../../../images/Register0.jpg" />
<img alt="../../../images/Register1.jpg" src="../../../images/Register1.jpg" />
<img alt="../../../images/Register2.jpg" src="../../../images/Register2.jpg" />
<p>上記の画像の内容が理解できれいれば, 上記URLのプログラム部で分からない部分はほぼ無いだろう.
<cite>REG</cite> マクロはアドレスの値を与えるとそこに参照する部分まで実行する(図で示しているが一応補足)
その値に対して&#8216;1&#8217;をセットした後, 必要分ビットシフトすることで目的のレジスタ値をセットしている.</p>
<p>画像で説明はしているが, <cite>map</cite>, <cite>munmap</cite> の詳細は以下に記述しておく.</p>
<ul class="simple">
<li><cite>mmap</cite>, <cite>munmap</cite> : <a class="reference internal" href="../../Library/Sys/mman.h.html"><span class="doc">mmap.h</span></a></li>
</ul>
</div>
<div class="section" id="id4">
<h3>動作<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>プログラムの解説が終わったところで動作させてみる. 今回はGPIO4番ピンをOUTPUTにして, High/Low の出力をさせるようにしている. ここで, Raspiの3.3V からLED, 抵抗を通して4番ピンを接続した状態で, プログラムを動作させると, 4番ピンが一度 High になった後, Lowになる(一度Highにする必要性は無いが今回は勉強のため) つまり, 3.3VからLED, 抵抗を通してLowになるのでLEDが発行する. ここで, プログラムの中の4番ピンをLowにするコードをコメントアウトして再度実行してみる. すると, 電源も出力もHighなのでLEDが発行しない.</p>
<p>さて, ここまでで基本的な流れは理解できたので, 次はプログラムを修正することなくLEDの発光を制御するもの, すなわち「デバイスドライバー」を作ってみる.</p>
</div>
</div>
<div class="section" id="id5">
<h2>デバイスドライバをカーネルモジュールとして実装する<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id6">
<h3>仕様<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ついに本当のデバドラをつくる. 今回は簡単のために以下のような仕様にする.</p>
<ul>
<li><dl class="first docutils">
<dt>open</dt>
<dd><ul class="first last simple">
<li>GPIO4を出力設定にする.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>close</dt>
<dd><ul class="first last simple">
<li>なにもしない</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>write</dt>
<dd><ul class="first last simple">
<li>&#8220;1&#8221; でHigh出力. &#8220;0&#8221;でLow出力</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>read</dt>
<dd><ul class="first last simple">
<li>現在の出力値を&#8221;0&#8221;か&#8221;1&#8221;で返す</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>また, 今回はユーザ空間ではなくカーネル空間で話を進めていくのでそのことも念頭に置く.</p>
</div>
<div class="section" id="id7">
<h3>実装<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>カーネル空間では, 物理アドレスから(カーネル)仮想アドレス(非キャッシュ)への変換には <cite>inoremap_nocache</cite> を使用する. 上記ユーザ空間の場合ではある程度の領域を決め打ちで取得していたが, カーネル空間では全体で一つのアドレス空間しか持たないため, レジスタアクセスのたびに4Byteずつ変換して使うことにする. (本来どうするべきなのだろう...?)</p>
<p>アドレス変換が終わったら, あとは, ユーザ空間のプログラムと同じようにレジスタアクセスができる. なおユーザ空間とのデータのやり取りは, 以前 <cite>copy_to_user</cite>, <cite>copy_from_user</cite> を使用していたが, 今回は <cite>put_user</cite>, <cite>get_user</cite> を使用することにする.</p>
<p>ここで利用している, <cite>ioremap_nocache</cite>, <cite>iounmap</cite> に関しては少なくとも, 標準ライブラリにはなく, 冒頭で導入したラズパイ用カーネルヘッダの中のものである( <cite>linux/io.h</cite>, <cite>asm/io.h</cite> どちらを利用しても動作したが, 名前的に <cite>asm/io.h</cite> のほうが良いだろう(機能自体はあらかた同じだと思うので, 以下のindexには, <cite>linux/io.h</cite> として記述する). またこれまでのライブラリももしかしたらカーネルヘッダのライブラリを参照していたかもしれない(Makeを要確認)</p>
<ul class="simple">
<li><cite>ioremap_nocache</cite>, <cite>iounmap</cite> : <a class="reference internal" href="../../Library/Kernel/linux/io.h.html"><span class="doc">io.h</span></a></li>
<li><cite>put_user</cite>, <cite>get_user</cite> : <a class="reference internal" href="../../Library/Kernel/linux/uaccess.h.html"><span class="doc">uaccess.h</span></a></li>
</ul>
<p>下に少し図解を入れておく.</p>
<img alt="../../../images/KernelUserMemory.jpg" src="../../../images/KernelUserMemory.jpg" />
<p>いい節目なのでコードを添付しておく.
上記URLとほぼ同じだが, 自分がわかるように多少のコメントを残している.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/cdev.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/device.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;asm/io.h&gt;</span><span class="cp"></span>

<span class="c1">// raspi peripherals macro</span>
<span class="cp">#define REG_ADDR_BASE 0x3F000000</span>
<span class="cp">#define REG_ADDR_GPIO_BASE (REG_ADDR_BASE + 0x00200000)</span>
<span class="cp">#define REG_ADDR_GPIO_GPFSEL_0 0x0000</span>
<span class="cp">#define REG_ADDR_GPIO_OUTPUT_SET_0 0x001C</span>
<span class="cp">#define REG_ADDR_GPIO_OUTPUT_CLR_0 0x0028</span>
<span class="cp">#define REG_ADDR_GPIO_LEVEL_0 0x0034</span>
<span class="cp">#define REG(addr) (*((volatile unsigned int*) (addr)))</span>
<span class="cp">#define DUMP_REG(addr) printk(&quot;%08X\n&quot;, REG(addr))</span>

<span class="c1">// device information</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;Dual BSD/GPL&quot;</span><span class="p">);</span>
<span class="cp">#define DRIVER_NAME &quot;MyDevice&quot;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">MINOR_BASE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">MINOR_NUM</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mydevice_major</span><span class="p">;</span> <span class="c1">// major number of device driver</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cdev</span> <span class="n">mydevice_cdev</span><span class="p">;</span> <span class="c1">// charactor device object</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">mydevice_class</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// device driver class object</span>


<span class="c1">// ##### device open/read/write/close handler ##### //</span>
<span class="c1">// implement the Raspi Peripheral address I/O access in these handlers</span>

<span class="c1">// open handler</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mydevice_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="s">&quot;mydevice_open&quot;</span><span class="p">);</span>

  <span class="c1">// ARM Physical Address -&gt; Kernel Virtual address Mapping</span>
  <span class="c1">// Peripheral (GPFSEL0) address mapping</span>
  <span class="kt">int</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">REG_ADDR_GPIO_BASE</span> <span class="o">+</span> <span class="n">REG_ADDR_GPIO_GPFSEL_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

  <span class="c1">// set GPIO4 is OUTPUT</span>
  <span class="n">REG</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>

  <span class="c1">// Unmap GPSEL0 map</span>
  <span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">address</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// close handler</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mydevice_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="s">&quot;mydevice_close&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// read handler</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mydevice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_pos</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="s">&quot;mydevice_read&quot;</span><span class="p">);</span>

  <span class="c1">// ARM Physical Address -&gt; Kernel Virtual address Mapping</span>
  <span class="c1">// Peripheral (GPFLEV0) address mapping</span>
  <span class="c1">// (GPLEV0 is 32bit data -&gt; get 4byte (32bit) from GPLEV0 start address)</span>
  <span class="kt">int</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">REG_ADDR_BASE</span> <span class="o">+</span> <span class="n">REG_ADDR_GPIO_LEVEL_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

  <span class="c1">// Get state of GPIO4 from GPLEV0 (0(Low)/1(High))</span>
  <span class="c1">//</span>
  <span class="c1">// (consider under 4 bit)</span>
  <span class="c1">// GPIO4 is High -&gt; (Register is) ...1000 : (...1000) &amp; (...1000) = ...1000</span>
  <span class="c1">// GPIO4 is Low  -&gt; (Register is) ...0000 : (...0000) &amp; (...1000) = ...0000</span>
  <span class="c1">//</span>
  <span class="c1">// if the (REG(address) &amp; (1 &lt;&lt; 4)) is    0 -&gt; val = 0</span>
  <span class="c1">// if the (REG(address) &amp; (1 &lt;&lt; 4)) isn&#39;t 0 -&gt; val = 1</span>
  <span class="c1">//</span>
  <span class="c1">// (ex)</span>
  <span class="c1">// printf (&quot;%d\n&quot;, (10 != 0)); // &gt; 1</span>
  <span class="c1">//</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">REG</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// return the state of GPIO to user as charactor</span>
  <span class="c1">// put the data to user space buffer.</span>
  <span class="c1">// this buffer is read by user.</span>
  <span class="c1">//</span>
  <span class="c1">// *** WARNING ***</span>
  <span class="c1">// if you put your data of int value, you would use &#39;itoa&#39; function.</span>
  <span class="c1">// but, in kernel space, you can&#39;t use this function.</span>
  <span class="c1">// Now you have to print the &#39;0/1&#39; of int value, you remember</span>
  <span class="c1">// (char) &#39;0&#39; -&gt; (int) 48</span>
  <span class="c1">// (char) &#39;1&#39; -&gt; (int) 49</span>
  <span class="c1">// so, you add your int 0/1 data to &#39;0&#39;, so</span>
  <span class="c1">// 0 + &#39;0&#39; = 48</span>
  <span class="c1">// 1 + &#39;0&#39; = 49</span>
  <span class="c1">// so, you can print it to &#39;0&#39; or &#39;1&#39;.</span>
  <span class="n">put_user</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// Unmap GPLEV0 map</span>
  <span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// write handler</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mydevice_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_pos</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="s">&quot;mydevice_write&quot;</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">address</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">outValue</span><span class="p">;</span>

  <span class="c1">// Get the GPIO4 output value from user space buffer</span>
  <span class="c1">// this buffer is setted by user input.</span>
  <span class="n">get_user</span><span class="p">(</span><span class="n">outValue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// ARM Physical Address -&gt; Kernel Virtual address Mapping</span>
  <span class="c1">// Peripheral (GPFLEV0) address mapping</span>
  <span class="c1">// User set output &#39;1&#39; -&gt; set GPSET0 of GPIO4</span>
  <span class="c1">// User set output &#39;0&#39; -&gt; set GPCLR0 of GPIO4</span>
  <span class="c1">// (GPSET0/GPCLR0 is 32bit data -&gt; get 4 byte (32bit) from GPSET0/GPCLR0 start address)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">outValue</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">REG_ADDR_GPIO_BASE</span> <span class="o">+</span> <span class="n">REG_ADDR_GPIO_OUTPUT_SET_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">REG_ADDR_GPIO_BASE</span> <span class="o">+</span> <span class="n">REG_ADDR_GPIO_OUTPUT_CLR_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// set GPSET0/GPCLR0</span>
  <span class="n">REG</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>

  <span class="c1">// Unmap GPSET0/GPCLR0 map</span>
  <span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// systemcall handler table</span>
<span class="k">struct</span> <span class="n">file_operations</span> <span class="n">s_mydevice_fops</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">mydevice_open</span><span class="p">,</span>
  <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">mydevice_close</span><span class="p">,</span>
  <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mydevice_read</span><span class="p">,</span>
  <span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">mydevice_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// ##### Kernel Module load / unload handlers ##### //</span>
<span class="c1">// insmod handler</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mydevice_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;mydevice_init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">alloc_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">cdev_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">dev_t</span> <span class="n">dev</span><span class="p">;</span>

  <span class="c1">// *** Creating Device and Register Kernel ***</span>
  <span class="c1">// 1. get major number (dinamically)</span>
  <span class="n">alloc_ret</span> <span class="o">=</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_BASE</span><span class="p">,</span> <span class="n">MINOR_NUM</span><span class="p">,</span> <span class="n">DRIVER_NAME</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">alloc_ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;alloc_chrdev_region = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alloc_ret</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 2. fetch major number from dev object.</span>
  <span class="n">mydevice_major</span> <span class="o">=</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
  <span class="n">dev</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">mydevice_major</span><span class="p">,</span> <span class="n">MINOR_BASE</span><span class="p">);</span>

  <span class="c1">// 3. initialize cdev structure and register systemcall handler to it</span>
  <span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydevice_cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_mydevice_fops</span><span class="p">);</span>
  <span class="n">mydevice_cdev</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

  <span class="c1">// 4. register cdev to kernel using &#39;cdev&#39; and &#39;dev&#39;</span>
  <span class="n">cdev_err</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydevice_cdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_NUM</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cdev_err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;cdev_add = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alloc_ret</span><span class="p">);</span>
    <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_NUM</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// *** Automatically Creating /dev/mydevice* ***</span>
  <span class="c1">// 1. register class of this device (create /sys/class/mydevice/)</span>
  <span class="n">mydevice_class</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="s">&quot;mydevice&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mydevice_class</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;class_create</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydevice_cdev</span><span class="p">);</span>
    <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_NUM</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 2. create /sys/class/mydevice/mydevice* to create /dev/mydevice*</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">MINOR_BASE</span><span class="p">;</span> <span class="n">minor</span> <span class="o">&lt;</span> <span class="n">MINOR_BASE</span> <span class="o">+</span> <span class="n">MINOR_NUM</span><span class="p">;</span> <span class="n">minor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">device_create</span><span class="p">(</span><span class="n">mydevice_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">mydevice_major</span><span class="p">,</span> <span class="n">minor</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;mydevice%d&quot;</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// rmmod handler</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mydevice_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span> <span class="p">(</span><span class="s">&quot;mydevice_exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="kt">dev_t</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">mydevice_major</span><span class="p">,</span> <span class="n">MINOR_BASE</span><span class="p">);</span>

  <span class="c1">// 1. delete /sys/class/mydevice/mydevice*</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">MINOR_BASE</span><span class="p">;</span> <span class="n">minor</span> <span class="o">&lt;</span> <span class="n">MINOR_BASE</span> <span class="o">+</span> <span class="n">MINOR_NUM</span><span class="p">;</span> <span class="n">minor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">device_destroy</span><span class="p">(</span><span class="n">mydevice_class</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">mydevice_major</span><span class="p">,</span> <span class="n">minor</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// 2. delete /sys/class/mydevice/</span>
  <span class="n">class_destroy</span><span class="p">(</span><span class="n">mydevice_class</span><span class="p">);</span>

  <span class="c1">// 3. delete device driver from kernel</span>
  <span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydevice_cdev</span><span class="p">);</span>

  <span class="c1">// 4. delete major number</span>
  <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_NUM</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// register handler</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">mydevice_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">mydevice_exit</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id8">
<h3>動作<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のようにビルドしてカーネルに組み込む.</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span>make
sudo insmod MyDeviceModule.ko
<span class="nb">echo</span> <span class="s2">&quot;0&quot;</span> &gt; /dev/mymodule0
<span class="nb">echo</span> <span class="s2">&quot;1&quot;</span> &gt; /dev/mymodule0
cat /dev/mymodule0
&gt;&gt; 1111111111111111^C
</pre></div>
</div>
<p>echo で &#8216;0&#8217; または &#8216;1&#8217; を書き込むことで, GPIO4の出力が変わり, LEDがチカチカする.
また, catで読み込むことで出力レベルが表示される. (Ctrl-cで止める)</p>
</div>
</div>
<div class="section" id="id9">
<h2>おまけ<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下のコマンドで, 物理メモリマップを確認できる.
これをみると今までの議論と同じようになっていることがわかる.</p>
<p><cite>sudo cat /proc/iomem</cite></p>
<p>SDRAMは物理アドレスの0番地から配置されている. 00000000-3b3fffff となっている. 0x3b3fffff = 994050047 = 約1GByteなので, 実際とも合っていそう. また, ペリフェラルレジスタアドレスも0x3fXXXXXX に配置されている.</p>
</div>
<div class="section" id="id10">
<h2>用語解説<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="id11"><strong>ページ</strong></p>
<div class="line-block">
<div class="line">ページに関して</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="06.ioctl_implementation.html" class="btn btn-neutral float-right" title="06. ioctl Implementation" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="04.read_write_and_memory.html" class="btn btn-neutral" title="04. read/write and Memory" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, mikiyaf.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../static/jquery.js"></script>
      <script type="text/javascript" src="../../../static/underscore.js"></script>
      <script type="text/javascript" src="../../../static/doctools.js"></script>
      <script type="text/javascript" src="../../../static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../../static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>