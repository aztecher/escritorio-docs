==============
Build
==============

ここではビルドに関するほぼ全ての内容を記述していく.

Abstract
=============

ビルドとは, 「材料となるファイルから何かしらの成果物を作成する処理」である. C/C++のようなプログラムでは, ビルドの成果物として挙げられるのは, ライブラリや実行ファイルである.


Processing
==============

ビルドは具体的に以下のフェーズに分かれている.

1. プリプロセッサ処理
2. コンパイル処理
3. リンク処理

それぞれに関して具体的に記述する.

PreProcessor
--------------

プリプロセッサのより詳細な内容は, :doc:`PreProcessor` に記述する

ビルドを開始すると, まずプリプロセッサがソースファイル1つ1つに対して次のような処理を行なう.

* `#include`, `#define` などのプリプロセッサディレクティブの解決
* コメントの削除

少しだけ詳細を逸脱してここに記述する話として, `#include` の話がある. ソースファイルに `#include` が指定されている場合, プリプロセッサによって指定された名前のヘッダファイルを探索して(探索方法については詳細に記述する), ソースファイルのその位置に **中身をまるごとコピーする** .

つまり, `*.h` や `*.hpp` などはコンパイルの前に, `#include` の指示に従って, `*.c`, `*.cpp` へ丸コピされた状態になるということである.

Compiler
----------

プリプロセッサを通過したソースファイルはコンパイラに渡され, コンパイルが実行される.

コンパイルとは「人間が読み書きしやすいように設計された言語(高水準言語)で書かれたプログラムをコンピュータが理解しやすい形式に翻訳する処理」を意味する. 例えば, 「C/C++で書かれたファイルをアセンブラ言語のファイルに変換する処理」である. コンパイラはプリプロセッサから受け取ったソースファイル1つ1つをアセンブラ言語のファイルに変換する. このようにして作成されたアセンブラ言語のファイルを機械語のファイル( **オブジェクトファイル / バイナリファイル** )に変換する.

さて, コンパイラによりそれぞれのファイルがオブジェクトファイルに変換されたわけだが, このときソースファイルをまたいで参照されている関数はどうやって処理されているのだろう. この問題を解決する仕組みが, **ヘッダーファイル** と **プロトタイプ宣言** である. ヘッダファイルには関数のプロトタイプ宣言が書かれている(実装でなく, 定義が書かれているのが一般的)ので, これが `#include` で読み込まれて展開されるというのはプロトタイプ宣言と同義である. この情報があることにより, 「ある関数はどのような型の引数をいくつ取り, 結果としてある型の値を返す」ということがわかる. コンパイラはその手がかりのみを元にコンパイルを完了させ, 中身に関しては保留する.

こうして, 他のファイルにある関数の実装が保留された状態( **外部参照が未解決である** という) のオブジェクトファイルが複数作成される.

Linker
--------

最後に生成された複数のオブジェクトファイルを纏める作業をリンクといい, これを実行するのがリンカである.

リンカはCompiler時点の, 外部参照が未解決であるような実装を順に探索していく. そして必要な情報をすべてまとめ, 1つの実行ファイルを作成する.


もう少し真面目に書くと以下のようである.

リンカは未解決の参照のリストを保持している. はじめ, このリストにはmainが入っている. リンカはオブジェクトファイル(.o)を受け取り, 参照を解決し, 新しい未解決の参照が見つかったらリストに追加する(リンクする). 静的ライブラリ(.a)を受け取った場合, 未解決の参照を定義しているオブジェクトファイルのみを静的ライブラリから抜き出し, リンクを行なう. いままで処理したオブジェクトファイルから参照されていないオブジェクトファイルは静的ライブラリに含まれていても無視される.

Library
=========

はじめに, ビルド処理による成果物には **ライブラリ** と実行ファイルという話をした.
実行ファイルに関してはこれまでの話でそれなりにイメージがついただろうが, ライブラリの場合はどうだろう. 以降, ライブラリに焦点を当てて話をしていく.

Abstract
---------

ライブラリとは, プログラムをいくつかの単位に分割して, 他人の書いたプログラムを再利用したり, ビルドの管理を楽にしたりする仕組みである.

例えば, `stdio.h` や `stdlib.h` などの標準ライブラリをこの仕組を利用している.

実行ファイル側からすると, ライブラリを別にするということは, **外部参照の実装を別にする** ということである. これだけ聞くとやはり単純にソースファイルによるコードの分割と同義であるといえるだろう. しかしながら後述するが, この外部参照の実装を呼び出せるように処理する場面, つまりリンク処理の場面において, プログラム内部に実装を埋め込むか, 実行ファイルとは別に動的に参照可能なファイルを作成するかという選択によって, ライブラリの種類が分かれることになる.

Library Type
--------------

現在, ライブラリには2種類ある. 一つは, **静的ライブラリ(Static Link Library/.lib)** で, もう一つは **動的ライブラリ(Dynamic Link Library/.dll)/共有ライブラリ** である.

恐ろしくザックリとした概要だけ話しておくならば, 静的ライブラリは隠匿性をとったものであり, ユーザによって実行できなくなるようなことがなくなるものである. 動的ライブラリは拡張性をとったものであり, プログラムの拡張が容易だったり実装の変更が容易だったりするものである.

Static Link Library (Windows: *.lib, OSX/Linux: lib*.a)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

静的ライブラリは静的リンク, つまりライブラリをプログラム内部に組み込むものであり, 実行ファイルには静的ライブラリが組み込まれている.

ライブラリの実装自体が実行ファイル内部に埋め込まれているため, 実行ファイル単体で動作させることが可能である. また, ライブラリ呼び出しの時間が短く, 高速に処理することができる.

その反面, 当然ながら実行ファイルの容量は大きくなる. また, ライブラリのバージョンアップが行われると, 実行ファイルも一緒に更新しないといけなくなる. この作業においてライブラリ自体に関わるソースファイルはコンパイルするものの, 実行ファイルのみに関わるソースファイルの更新は(本来)必要ないが, リンカによるリンクは再度行わなければならない. また, 同様のライブラリを使用する別のアプリケーションを動作させる場合でも, 実行ファイル毎にライブラリのコードがメモリに読み込まれることになり, メモリの使用量が大きくなる.

Dynamic Link Library (Windows: *.dll, OSX: lib*.dylib, Linux: lib*.so)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

動的ライブラリ(共有ライブラリ)は動的リンク, つまりライブラリがプログラム内部から分離されており, 実行時に必要なものを外部から動的に呼び出して実行する.

メモリ上に読み込んだ1つのdllを複数のアプリケーションで共有できるため, メモリの使用量を節約することができる. また, 実行ファイルに埋め込まないため, 実行ファイル自体のファイルサイズは小さくなる. 更に, ライブラリアップデートの場合にも, dllファイルのアップロードのみをすればよく, 実行ファイルの再リンク処理などは必要ない.

ただし, 当たり前ながらdllファイルがなければ, 外部参照の実装が解決できないので, 実行ファイルは単体では動作しない. そのため, dllのリンクを正しく設定しておく必要がある.

dynamic loading
^^^^^^^^^^^^^^^^^

ライブラリの種類というよりは読み込み方の話なので多少毛色は違うものの, 関係のあるないようなのでここに記述しておく.

動的ライブラリ(静的ライブラリもだが...)は通常, 実装がある動的ライブラリへの参照を自身のソースコードに埋め込まなければならず, それが `#include` による **ヘッダーファイルのインクルード** である. つまり, これをやっておいて実行時に実装のある `.dll` ファイルが見つかれば実行できる. これを拡張したような利用形式に, **動的読み込み (dynamic loading)** がある. これはヘッダーファイルなどは必要なく, 自身のソースコードだけでビルドが可能である. しかしながら, 結局参照はしなければならないので, 自身のソースコード内に, 「 `**` という名前の動的リンクライブラリの `**` という関数を呼び出す」ということを記述してあげないといけない.

この方式は, ライブラリファイルの探索やロードの処理もプログラム上で細かく実装することができたり, 実行ファイルのコンパイル時点でライブラリが完成していなくてもよかったりというメリットが有り, プラグイン機能の開発に利用されることが多いようである.

ただし, 実行ファイルの作成時点ではライブラリの名前と関数名が大文字として埋まっているだけであり, コンパイルの恩恵(型の管理, 関数名の管理などを自身で行わないといけない)という欠点がある.

lib vs dll
------------

静的ライブラリであれ動的ライブラリであれ, 結局最終的には **未解決の外部参照の実体を記述したもの** であり, これをどのように参照可能にするかの違いしか無いわけである. それぞれの違いやメリット/デメリットは上に記述したとおりであるが, 一概には言えないが, dllの方が利点の数では軍配が上がるだろう.

実際, 大抵のライブラリはdllファイルとなっているようである. libファイルはバージョンアップされることがほぼ無い標準的なもの, 例えばC/C++の標準ライブラリ等くらいのものではないだろか.


How To Make
--------------

MacOS/Linux
^^^^^^^^^^^^

普通, Windowsから説明するものかもしれないが, Mac/Linuxによる作り方(どうせCCコマンドオプションとかリッチに言ってもMakeを使う程度)がわかっていれば本質的に理解できるのでこちらから説明する.

注意されたいのは, MacOS/Linuxは基本的にコマンドが同じだろうという憶測から同一視して書いていることである. 多少コマンドが違うことはあるだろうがそこらへんは探せばわかるので各個人に任せることとする.

ただし, おそらくフォーマット自体は違うものになることは想定できる. Objectファイル一つをとっても, LinuxはELFでMacはなんか良く分からん感じのフォーマットだった記憶がある. これに関しては注意を払うべきであろう.

*静的ライブラリ*

静的ライブラリは実はオブジェクトファイルを(インデックス付して)まとめたただのアーカイブである. そのため, objファイルを生成して, `ar` コマンドでアーカイブするだけでいい.

ただし, 名前には注意が必要で, `lib*.a` という名前にしなければならない.

例えば, `static-library.c` というソースファイルを利用して静的ライブラリを作成する場合は以下のような流れになる.

.. code-block:: sh

    # 1. オブジェクトファイル(static-library.o)を作成
    gcc -c static-library.c

    # 2. 静的ライブラリ(libstatic.a)にまとめる
    ar r libstatic.a static-library.o

    # 3. 別のソースファイル(main.c)で静的ライブラリを使用する
    gcc  main.c -lstatic

*動的ライブラリ(共有ライブラリ)*

(動的ライブラリに関しては拡張子の時点でMac(.dylib)とLinux(.lib*.so)は違うので, 以降はMacに関する方法と捉えておくといい. ただし, Linuxでも手続き的にはほぼ同じだろう)

続いて, 動的ライブラリ(共有ライブラリ)についてである. これも基本的には同じような流れである. ただし, 「まとめる」という操作がないぶん, コンパイルオプションを付加するだけで直接作成することが可能である.

.. code-block:: sh

    # 1. 動的ライブラリ(共有ライブラリ)を作成(shared-lib.c)
    gcc -dynamiclib -o libshared.dylib shared-lib.c

    # 2. 別のソースファイル(main.c)で共有ライブラリを使用する.
    gcc -o main main.c libshared.dylib

.. warning::

    コンパイルフラグである ``-lXXX`` は **GCC** の場合はコマンドの最後につける.
    ``ld`` (GNUリンカー)のドキュメントにもあるように, **コマンドラインで指定された場所でアーカイブを一回だけ検索する** らしい.
    つまり, **そのフラグ前のオブジェクトの中で未定義のシンボルを定義している場合に, リンカーはアーカイブから適切なファイルをインクルードする**
    そして, **コード行の後に表示されるオブジェクトの未定義シンボルによって, リンカーはアーカイブを再度検索することはない**

Windows
^^^^^^^^^

Windowsの話は基本的にVisual Studioを利用する方向性で進めていく. WindowsでもMakeが実行できるようだが, それに関してはMac/Linuxにおける場合とほぼ同じなので, そちらにまかせることにする.

VisualStudio一般に関しては, :doc:`VisualStudio/DetailedKnowledge` に記述しているのでそちらを参考されたし.


