==========================
Dynamic Memory Allocation
==========================

ここでは, C++におけるメモリの動的割り当てに関してと, それに関わる ``new`` と ``delete`` について説明していく

new/delete
===============

C言語であれば, 動的メモリ割り当てといえば, ``malloc()`` 関数があった. C++はC言語を用いることができるため, これを利用することは当然問題ない.

しかし, C++において, ``malloc()`` を使うことはあまり推奨されない. それは, C++には独自のメモリ割り当て演算子 ``new`` 演算子があるからである.

new演算子はmalloc()とは異なり, 割り当てるべきバイト数を自動計算してくれる.
sizeof()演算子を用いてこちらから指定する必要がないため, 割り当てミスの原因の一つが解消される.
また, 指定したデータ型または, オブジェクトの領域をメモリの ``ヒープ領域`` に割り当て, そのポインタを返す.

new演算子は, こうして割り当てたメモリへの ``ポインタを返す``.
問題は容量の関係でメモリを割り当てられなかったときの処理である.
標準C++では, ``例外`` というものを作成する. (後述)
しかし, これは最近の話でこれまではずっとNULLを返していた.
そのため, newが何を返すかというのは, コンパイラによって違う.
この講座は, 標準C++に基づいて解説してくるため, NULLを返すことは想定していない.

newで割り当てたメモリ領域は解放する必要がある.
``malloc()`` 関数に対し, ``free()`` 関数でメモリの割り当てを開放していたのと同じで, newで割り当てたメモリは ``delete`` 演算子で解放する.

pointerには, newで割り当てたメモリ領域へのポインタ変数を指定する.
それ以外のポインタを渡すと, プログラムがクラッシュする可能性がある.

.. code-block:: cpp

    // 最も基本的な例
    // 必要な分のメモリを確保できなかった場合の処理をしていない.
    // ここで割り当てるメモリサイズはごく僅かなので, まず失敗はないだろう
    
    #include <iostream>
    using namespace std;
    
    int main() {
      int *po;
      po = new int;
    
      *po = 100;
      cout << "動的に割り当てたメモリの内容 = " << *po;
      
      delete po;
      return 0;
    }


オブジェクトの割り当て
------------------------

クラス型のオブジェクトを動的に割り当てることも可能.
このとき, データ型と違うのは初期値を与えるという処理があること.

.. code-block:: cpp

    #include <iostream>
    using namespace std;
    
    class Kitty {
      public:
        Kitty(char *str) { cout << str; }
    };
    
    int main() {
      Kitty *obj;
      obj = new Kitty("Kitty on your lap\n");
    
      delete obj;
      return 0;
    }

delete でメモリを開放した時に, デストラクタ関数が呼び出される.

配列の割り当て
-----------------

new演算子で1次元配列を動的に割り当てることもできる.
ただし, 配列の場合は「初期化できない」ので注意.

配列を要求した場合, new演算子は割り当てた配列の先頭へのポインタを返す.
この場合, deleteでもnewで割り当てた配列の先頭へのポインタを指定する.

.. code-block:: cpp

    #include <iostream>
    using namespace std;
    
    class Kitty {
      public:
        ~Kitty() { cout << "Kitty on your lab\n"; }
    };
    
    int main() {
      Kitty *obj;
      obj = new Kitty[10];
    
      delete[] obj;
      return 0;
    }

クラス型の配列を動的に割り当てた場合, メモリ解放時には全てオブジェクトのデストラクタが実行される.
ただし, newで割り当てた領域が複数回解放されているわけではない.


