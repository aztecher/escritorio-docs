================
PreProcessor
================

ここでは, ビルド作業におけるプリプロセッサの詳細について記述していく

Abstract
----------

ビルド作業では, コンパイル処理の前工程として, プリプロセス(前処理)の工程がある. これはプリプロセッサ命令(プリプロセッサディレクティブ)の処理やコメントアウトの削除などの処理に相当する.

What's PreProcessor?
----------------------

プリプロセッサとはその名の通り「前処理をするもの」である.

C/C++のプログラムをコンパイルするのにCCなどのコンパイラを利用すると思うが, 実はその処理は何段階かに別れており, その処理の一番最初に行われる処理がプリプロセッサによる処理である. この処理を施した時点ではまだ高水準言語はそのままのレベルのコードであり, それを後続のコンパイル処理にかけることでバイナリレベルのコードに翻訳される.

さて, プリプロセスというのは一般的な言葉であり, 何かしらの重要な処理をするに当たって, その処理の準備として実行される処理(前処理)という意味を持っている. ビルド処理において, コンパイル処理という重要な処理に先立って, その準備となる処理を実行するため, このように呼ばれているわけである.

プリプロセッサの機能はコンパイラとは独立に用意されていることもあれば, コンパイラの機能の一部として含まれていることもある. 現在のCCのようなコンパイラはその本体にプリプロセッサ機能を搭載しており, オプションによりコンパイル処理を行わず, プリプロセッサが機能だけを動作させることも可能である. プリプロセッサ処理を直に確認したい場合には有効であろう. ここでは省略する.

PreProcessor Directive
-------------------------

プリプロセッサ命令は, C/C++でいうならば, ソースコード内の `#` 付きで始まる命令だと思ってもらって差し支えないだろう. 本記事では, `#define` `#include` に焦点を当てて説明するが, これらの考え方がわかればその他の指令に対してもさほど抵抗なく理解することが可能だろう.

#define (1)
^^^^^^^^^^^^^

`#define` はプリプロセッサ命令のうちでも最もよく使われる命令だろう. 特に数値や式に名前をつけるためによく用いられる.

たとえば, 以下のようなコードを書いたとしよう.

.. code-block:: c

    #define PI 3.14159265

    ....

    s = 2 * PI * r

これは, 円周率を示す数値に `PI` という名前を付けるという命令である. このようなソースコードをプリプロセッサに食わせることで, 以下のように展開される.

.. code-block:: c

    ...
    s = 2 * 3.14159265 * r

このような使い方は俗に, 「マクロ定義」と呼ばれる.
記述方法(構文)などの詳細は自明なのでここでは説明しないが,
「プリプロセッサディレクティブはプリプロセッサにより処理される」
ことを知っておくと, 以下のようなミスはめるだろう.

.. code-block:: c

    #define PI 3.14159265; # <- セミコロンを付けるエラー(よくある)

セミコロンはあくまで, 「コンパイラが1行を認識するために必要なもの」であり, この様に書くと, `PI` の値が, `3.14159265;` となり予期せぬエラーの原因となるわけである. プリプロセッサディレクティブがプリプロセッサ処理によって展開されることを知っておくとこれらのエラーは起こしにくくなるだろう.

さて, これがプリプロセッサの構文解析によってうまく展開される.
文字列で同様の `PI` があった場合はもちろん無視され, `PI2` などの変数があってもそこには展開されないようになっている. 細かい方法はプリプロセッサ自体の実装の話まで足を突っ込むことに成るので省略するが, プリプロセッサの構文解析の賜である.

余談だが, このように数値定数に名前をつけることはプログラムの可読性を上げるだけでなく, 修正を容易にしたりする効力もある. 名前付け(タグ付け)というのはプログラムの領域に限らず強力な手法である.


#include
^^^^^^^^^^

プリプロセッサはインクルード命令を見つけると, **ファイル名で示されたファイルの中身をその部分に挿入する** . ファイルの中身をそこに含める(include)ということから, `#include` 命令という名前がついたわけである. このように `#include` 命令で読み込まれるファイルは一般的に **ヘッダファイル** と呼ばれる.

当然ながらヘッダファイルが読み込まれることで, プログラムの行数は増える. もしもヘッダファイル内にまた, `#include` 命令があると, そこでまた別のヘッダファイルの読み込みが発生する.


さて, この挙動を知っていると納得のいくことと疑問に思うことがいくつかでてくるだろう.

まず真っ先に疑問に思うこととして, プリプロセッサは「ヘッダーファイル」をどこから探してくるのだろうかということである. これに関しては, 以下のような規則がある.

* `#include <ファイル名>` という形式の命令では, ヘッダファイルをシステム標準の場所から探す.
* `#include "ファイル名"` という形式の命令では, まず今コンパイルしようとしているプログラムと同じ場所からヘッダファイルを探し, 見つからなければシステム標準の場所から探す. この時, コンパイルオプションで任意のディレクトリを指定することができ, その場合はそのディレクトリも探索範囲に含める. プログラマが自身で作成したヘッダファイルを読み込ませたい場合はこの形式を使う.

システム標準のディレクトリ位置はおおよそそのOSに依存する. Linuxをはじめ, 大抵のUNIXでは, `/usr/include` というディレクトリ以下に標準的なヘッダーファイル, ないし標準的なヘッダーファイルを含むようなサブディレクトリが置かれている.


さて, 疑問は晴れたので次に納得のいくことについて明確にしておく. よくヘッダーファイルに書く内容については「マクロ定義, 新しい型の宣言, 関数の型の宣言(関数プロトタイプ宣言)」というように言われ, 「関数の中身, クラスの中身とかは記述してはならぬ」的なことを言われるだろう. つまり, 「定義・宣言」は記述するが, 「実体」は記述してはいけないということだ. これに関しては明快に理解することができるだろう.

一応, 正確に書いておくならば, ヘッダファイルに含めていいもの, ダメなものは以下のようになっている.

**ヘッダーファイルに含めていいもの**

1. 様々なマクロの定義
2. 新しい型の定義.
3. 関数の型の宣言. 正式には関数プロトタイプ

**ヘッダーファイルに含めてはいけないもの**

1. 記憶領域の確保(と初期化)を行なう文
2. 関数の定義. (宣言と定義は別)

`#include` はプリプロセッサによって展開され, そのヘッダーファイルの中身がその位置に直接書き出されるのであった. つまり, 「定義・宣言」が書き出されると, そのファイル内でその定義関数などが自由に使えるわけである. 実体に関しては, リンカーによって参照されることを期待すればよい. さて, ではここで例えば実体を書いてしまうとどうなるだろう. 例えば, `int i = 0` のような変数定義(変数iに対応して, int型の整数を入れるために必要な記憶領域を確保し, 初期値として0を設定する)をヘッダーファイルに書いていて, そのヘッダーファイルを `hoge.c` と `fuga.c` の両方で `#include` しているとする. この場合に `hoge.c` と `fuga.c` を利用するようなコンパイルをすると「 **iの多重定義エラー** 」が発生する. それ故に, ヘッダーファイルにて定義できるもの, できないものという切り分けが存在している.

とはいえ, 多重定義を避ける方法ももちろん存在する. それらは, `#ifdef` `#ifndef` などのプリプロセッサディレクティブであるが, ここでは詳細は省略する.

このようにプリプロセッサの挙動を知ることは, ヘッダーファイルの設計に関することやエラーデバッグに関することについての知見も与えてくれる.

#define (2)
^^^^^^^^^^^^^

再度, `#define` について説明する. こちらでは主に, 「パラメータ付きマクロ定義」について取り上げる. これはLinuxのソースコードなどを呼んでいるとガシガシ書かれているものであり, 非常に強力な能力である.

これに関しては少々丁寧に説明していく.

具体的に「パラメータ付きマクロ定義」では, 次のようなマクロ定義を行なう.

.. code-block:: c

    #define SQ(x) ((x) * (x))

上の例では, `SQ` がマクロ名, `x` がパラメータ, `((x) * (x))` 定義であり, 基本的には「名前付け」で見た方法と同じであるが, パラメータ部分を任意の表現で置き換えられるというのが違いである.

例えば, `SQ(3)` であれば, `((3) * (3))` と展開され, 値としては `9` を返すことに成る. 3の例ではあまり嬉しさが少ないだろうが, 例えば配列aのある要素(i+j+1)の二乗を得るなどの場合は, `SQ(a[i+j+1])` と書くだけなので, 展開後の式をべた書きするよりいくぶんかよくなりそうな雰囲気があるだろう.

パラメータは複数持たせることができる. マクロ定義の一般形は次のようになる.

.. code-block:: c

    #define マクロ名(パラメータ1, ... , パラメータn) 定義本体

ここで注意されたいのは, マクロ名と括弧の間である. ここにスペースを入れるとエラーになる.

パラメータを複数持つマクロとして次のような例が考えられる.

.. code-block:: c

    #define dist2(x,y) (SQ(x[0]-y[0]) + SQ(x[1]-y[1]) + SQ(x[2]-y[2]))

これはx, yをベクトルとした場合の距離の公式である.


さて, ここでも落とし穴が何個かある. 定義本体においてパラメータを示す場合は, パラメータを括弧で括る必要がある. 決まりと言ってしまえばそれまでだが, 難しい話ではないので少し考えてみよう. 以下のようなことが起きてしまう.

.. code-block:: c

    #define SQ(x) x*x

    SQ(a+1) # 本来 (a+1) * (a+1) を計算して欲しいが...
    > a + 1 * a + 1
    > a + (1 * a) + 1

パラメータをカッコでくくらないとこのような計算が起きるわけだ.
要するに演算の順位付け周りで問題ごとを起こしたくない場合は, 素直にパラメータを括弧で括るようにせよということである.


#define (3)
^^^^^^^^^^^^^^

さて, 上ではマクロをうまく利用する方法を説明したが(プリプロセッサの話からどうしてこうなった...?), ここの引数部分にはあまり複雑な式を書かないほうがいい. せいぜい四則演算や配列要素の値の取り出し, それらの組み合わせ程度に留めるべきである. 関数呼び出しや, i++ や i-- のような形, つまり変数や中身を変更するような式をマクロの引数部分に書くとトラブルになりやすいのでやめておくべきである.

先の例を取り上げると, この例では **パラメータを2回評価していた** . この文言だけであらかたわかるだろうが, 評価の回数は1度とは限らず, 例えば `i++` などは2回のインクリメントが発生するということが起こりうるわけである.


関数とマクロの使い分け
^^^^^^^^^^^^^^^^^^^^^^^^

プリプロセッサから完全に話が逸脱したが, まぁせっかくなのでここまで書いておくことにする.

引数を持つマクロと関数はよく似ている. 少なくとも呼び出し方はほぼ同じである. UNIXには, 関数のように思えるマクロが多数用意されており, それらは普通に使っている分にはほぼ関数と見分けがつかない(マクロと意識して使いことがない)ような場合が多い. これはカーネルのソースコードを追ってみると顕著である.

ただし, 我々の立場としては関数とマクロの間のはっきりした違いをしっかりと把握し, 御する力を持っていないと行けないだろう. その指針と成るように, どのような場面で関数を利用し, どのような場面でマクロを使うかの例をいくつか挙げてみる.


**関数呼び出しの手間を嫌ってマクロを使用**

CPUが関数呼び出しをするには多少手間がかかる. それはユーザプログラムに, 引数の指定や, 返り値の指定という形の手間で現れる. 例えば, 2乗を計算する関数を `square(x)` とすると以下のような実装になるだろう.

.. code-block:: c

    double sequare(double x) {
        return x * x
    }

たった, 2乗をするだけのコードに, 型や返り値のハンドリングをするのは手間であると言えよう. この程度の処理であれば先に定義した `SQ(x)` のようなマクロを使う価値があるだろう.

**複雑な処理は関数しかできない**

上でも少し話したが, マクロではパラメータの機械的な展開程度の処理しかできないので複雑な処理を書くべきではない. 条件判定程度の処理もループもできず, 別マクロは呼べても自身を再帰的に呼ぶことはできない. そのくらいの身分であることは肝に銘じておく.

**マクロは展開の度にコンパイルされる**

非常に複雑な長い表現に展開されるようなマクロを定義したとする. その場合そのマクロを何度も使うとその度に長い表現に展開され, それらが全てコンパイルされ展開されるので, プログラムの大きさが膨張することになる. これに対して関数は一度しかコンパイルされないため, 関数を度々呼び出してもプログラムはさほど大きくはならない.

**マクロでしか書けないこともある**

少しテクニカルな話のため, 直接の言明は避けるが, 関数では書けない便利なマクロを定義することが可能だったりもする.

**使い分けの目安**

上記のような話から, 割合簡単な処理を高速に実行したい場合はマクロで記述するメリットが生まれやすく, 複雑な処理では関数で記述すべきケースが多くなると考えられるだろう. とはいえ, 明確なせんびきは無いので, マクロの落とし穴にも注意した上で使い分けるべきだろう.

Other Function of PreProcessor
---------------------------------

さてすっかり忘れてしまっていたが, 本稿はプリプロセッサの話であった. 特に `#define` `#include` というプリプロセッサディレクティブに着目し, プリプロセッサの動作について説明し, それ故に発生する問題点やその改善方法などの言明を行ってきた.

もちろんこれら以外にも, プリプロセッサには様々な機能がある. 詳しい説明はしないが, 以下にリストアップしておくので, 各々必要なタイミングで確認しておくといいだろう.

マクロ定義の抹消
^^^^^^^^^^^^^^^^^^

`#undef` 命令を用いると, 定義されていたマクロを未定義に戻すことができる.

条件付きコンパイル
^^^^^^^^^^^^^^^^^^^

`#if`, `#ifdef`, `#ifndef` などを用いると, ある条件下である領域のコードをコンパイルするというような指定ができるようになる. Linuxではこちらを実行するが, Windowsでは別の処理をするなどの記述に使える.
