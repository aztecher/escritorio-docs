====================
What is DI
====================

DI
===

DIとは. hogehoge


DIの重要性はここ数年で急速に高まってきている. 依存性が注入されたりとかはどうでもよく, 設計と実装を分けたいということを工夫を凝らした結果行き着いた先の一つがDIだったのだろう.

Haskellでも設計と実装を分けるためにDIしたいというのは自然である.

ここでは, 型も含めて設計が実装に依存してはいけないことを要求する. 例えば, 設計でMySqlConnection, みたいな型が出現することも分離できていないので禁止とする.

Problem
=========

設計を定義するときには, 他の言語ではインターフェースなどの仕組みが使われることが多い. Haskellには型システムという仕組みがあるため, これがインターフェース相当の機能として紹介される場合がある.

しかしながら, 型システムはインターフェースとは違い, 型を固定する仕組みがない. 型クラス `TypeClass a` のインスタンス値が `x:TypeClass a => a` と `y:TypechClass a => a` のように2つ与えられたとしても, x と y が同じ型である保証はないし, これが同じ方であることを矯正するには x と y を同時に作って同時に運ぶ必要がある.

というわけでインターフェースを使うと方が固定できないのでDIしようとすると困ったことになる, と考えられそうである.

存存型とreflection
=====================

型を固定する仕組みは実はどうにかできる. 要は存在型を使って `data Trapped = forall a. TypeClass a =>  Trapped a` とやると型を外から見えないように隠蔽することができる.

存在型は中を開いたときにもともと何が入っていたかはわからなくなるが, 設計ではそれを意識するはずがないので特に問題ない.

さらに, いわゆるDIコンテナ的な仕組みでは生成したオブジェクトが必要な所に注入してくれるという機能があることは多いが, 実はこれとおなじこともHaskellではできる.

reflection_ というパッケージがあり, これはconfigデータを外から与えるためによく使用される. `Given a => ...` なる型を持つプログラムは `given` と書くといつでも好きなタイミングで外から挿入された値を取り出すことができる.

同じ型に対しては一つの値しか注入できないが, 実際にDIするときには利用する型は1つだけで問題がない.

というわけで, これでHaskellでDIができそう! ということが分かる.

Loggerの例を :doc:`./DI_Logger` に示す.

.. _reflection: https://www.stackage.org/lts-11.16/package/reflection-2.1.3
