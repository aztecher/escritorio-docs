=================================================
Parametric Polymorphism (パラメータ多相型)
=================================================

基礎としてパラメータ多相型について記述していく.

forall a
=========

polymorphic (ポリモーフィック, 多相型) 関数とは, 「多くの異なる型に対して作用する」関数である.
例えば, Length関数である.

.. code-block:: hs

    length :: [a] -> Int

これはどのようなリストに対しても(リストの要素が何であれ)適用できる.
そのため, length関数の定義にある型変数 `a` はどのような型も取りうる
ほかにも, 例えば以下のようなものがあるだろう.

.. code-block:: hs

    fst :: (a, b) -> a -- タプルの最初を取り出す first 関数
    snd :: (a, b) -> b -- タプルの二番目を取り出す second 関数
    map :: (a -> b) -> [a] -> [b] -- リストからリストへマップする map 関数

型変数は, 通常の型(具象型)のように大文字から始めるのではなく, 必ず小文字から始める.
逆に小文字から始まるものは, 型変数として認識される.
これは処理系の話である.

また, 「型変数であることを明示したい」ならば, `forall` を使う.

.. code-block:: hs

    length :: forall a. [a] -> Int

これは「全ての型 `a` に対して (for all type `a`), length関数は, 型 `a` の要素を持つリストを引数にとり, 整数を返す」となる.
つまり, 最初に示した例は単に `forall` を省略したものであるといえる.
この `forall` のような, 「変数を修飾してすべてのものを指すようにするキーワード」を「全称量子化子」と呼ぶ.


Polymorphism 高階型
====================

さて話を戻すと, polymorphic (ポリモーフィック, 多相型) 関数とは, 「多くの異なる型に対して作用する」関数であった.
先程 `forall` キーワードを導入したため, 我々はPolymorphicな引数を取る関数を定義できるようになった.

.. code-block:: hs

    foo :: (forall a. a -> a) -> (Char, Bool)
    foo  f = (f 'c', f True)

定義から第一引数 `f` は「任意の型をとり, それと同型を返す関数(多相型関数)」であり, この foo 関数はその多相型関数に 'c' と True を与えたものをタプルにしている.
この多相型関数は必ず同型を返すため, 返り値の定義は(Char, Bool)と定まる.

さて, ここで似たようなシグネチャを持つ関数barを以下のようにかんがえる.

.. code-block:: hs

    bar :: (a -> a) -> (Char, Bool)

これはすなわち以下のような定義と同値である.

.. code-block:: hs

    bar :: forall a. ((a -> a) -> (Char, Bool))

さてこの定義, 先程の定義とは少し形が違うが, これは先ほどと同じなのだろうか, 違うのだろうか...というのがこの議題.
答えを先に行っておくと, これは先程のものとは異なる, つまり

.. code-block:: hs

    -- これらは明確に異なる
    foo :: (forall a. a -> a) -> (Char, Bool)
    bar :: forall a. ((a -> a) -> (Char, Bool))

では, どう違うのだろうか. 冷静に見てみると, forall a. がかかっている範囲をあえてくくりだすと, 前者は ( a -> a ), 後者は ((a -> a) -> (Char -> Bool)) である.
fooを言語化するならば「どのような型でも受け取って同じ型を返すような関数 (ex: id :: a -> a) ならば入力する」であり,
barを言語化するならば「ある特定の型に対して, それと同じ型を返すような関数ならば, どのような関数fでも (ex: abs :: Num a => a -> a) 入力する」である.
少しの違いが, 意味において重大に異なることがわかるだろう.

このbarのような単純な多相型関数を1階型(rank-1 type)と呼ぶ.
またfooの型は2階型に属する.
さらに, (n-1)階型の引数を1つ以上取る関数をn階型と呼ぶ.

My Recognition
-----------------

さて, ここで私は初めイマイチ理解できなかったので実装を元に考えていくことにした.
プログラムは, :doc:`Program/ParametricPolymorphism.hs` に記述しているが, 以下に示す程度のものである.

ひとまず, fooを実装してみる. 言語拡張を忘れずに行う.

.. code-block:: hs

    {-# LANGUAGE RankNTypes #-}
    
    -- これは上述した実装まま
    foo :: (forall a. a -> a) -> (Char, Bool)
    foo f = (f 'c', f True)

これは問題なく動作する.
さて, いまいちわからないbarの実装であるが, とりあえずfooのマネを試みたところ失敗した.

.. code-block:: hs

    -- fooと同じと仮定して同様に実装する ---> Error
    bar :: forall a. ((a -> a) -> (Char, Bool))
    bar f = (f 'c', f True)

こんな愚かなことをしてはいけない.
さて, ここでピンときた(というよりちゃんと記述してあるんだが...)のは,
この定義型は以下のようであった.

.. code-block:: hs

    bar :: forall a. (a -> a) -> (Char, Bool)
    bar :: (a -> a) -> (Char, Bool)

さてこれで明確に理解できた.
すなわちbar関数は, 「ある関数を受け取るが, その関数はある特定の任意型を取り, それと同じ型を返す」というものである.
言ってること同じじゃねぇかと思うかもしれないが冷静に考えて欲しい.
この場合に取る任意の関数 f は例えば, (Int -> Int) であったり, (Char -> Char), (Bool -> Bool) であったりするわけだが,
これは関数に渡される時点で決まる必要がある.
すなわち, これらの関数を同じ型に適用できても, 異なる型に適用できないのだ.

具体例を考える.
今, ある関数 f を (Char -> Char) と考えると, bar関数はそれを 'c' と 'True' に適用することになる.
しかしながら, 'c' には適用できても, 'True' には適用できないのは自明である.
それ故エラーになるのだ.

これを解決したいならば, 「引数となる関数 f 自体が任意の型を取れる関数」であるようになっていないと行けない.
つまり, 引数として適用する関数の定義(型)が (a -> a) でないといけないのだ.
そうであれば, 例えば `id :: a -> a` を考えると, id 関数に引数として 'c' を返渡すとその時点で型が決まり 'Char' を返し,
同様に 'True' を渡すと 'Bool' を返すのである.

これを実行するのが, 先の foo 関数である.
再度定義を見て考えてみる.

.. code-block:: hs

    foo :: (forall a. a -> a) -> (Char, Bool)

さて先程のよく分からない状況と比べていくらかわかるようになっただろうか?
つまり, `(forall a. a -> a)` が示すのは, 「任意の型 `a` を取って, どの同型を返す関数ならば...」である.
また, ここまで見てきたら分かる通り, この第一引数の関数は要するに `(a -> a)` という型定義の関数であることを示している.
このように, 「現在の関数に渡す関数を多相関数であるようにする」という階層のような定義になっており, rank と言われるわけなのだろう.

さて, ながなが書いたがまぁ簡潔にまとめると.

.. code-block:: hs

    (forall a. a -> a) -> (Char, Bool) : 第一引数の関数が多相型関数である.
    forall a. ((a -> a) -> (Char, Bool))
    = forall a. (a -> a) -> (Char, Bool)
    = (a -> a) -> (Char, Bool) : 第一引数は「ある特定の型を受け取り(なんでもいいが決まっている型), 同型を返す」と決まっている関数.

ということである.
言葉で表すのは難しいな...

RankNTypes
============

せっかくなので少し触れておく.
一般の高階型のシステムは `System F` によって論理的に解析できるそうな.
`System F` は `second-order lambda calculus` としても知られているとか.
上のfoo/barの例で示したものは, 別のセクション(興味があれば書く)で解説する.

Haskell98は, `System F` よりも制約条件の強い `Hindley-Milner` の型システムに基づいているらしく, `forall` を使った2階型や, 高階型をサポートしていないそうな.
それゆえ, これらの制約を外し, `System F` の強力な力を得るために, `RankNType` 拡張を利用するということらしい.

runST
======

(*) ここの話はもう少し私がSTモナドに詳しくなったら再度確認して編集.

Haskellで実用的なプログラムを書く人間にとっては, `ST Monad` が実際に使う型としては初めての rank-2 type になるだろう.
この型は, `IO Monad` と同じ様に「変更可能な参照と変更可能な配列」を与える.

.. code-block:: hs

    newSTRef :: a -> ST s (STRef s a)
    readSTRef :: STRef s a -> ST s a
    writeSTRef :: STRef s a -> a -> ST s ()

型変数 `s` は read/write で変更される状態を表現している.
しかし, IOとは異なり, このステートフルな計算を純粋なコードの中で行うことができる.
特に次の `runST` 関数は, 初期状態を設定し, 計算を実行し, 状態を捨てて計算結果を返す.

.. code-block:: hs

    runST :: (forall s. ST s a) -> a

これには rank-2 type が使われている. なぜだろうか?

ポイントは, 「変更可能は参照は一つの `runST` に対してローカルであるべき」ということである.
具体的には,

.. code-block:: hs

    v = runST (newSTRef "abc")
    foo = runST (readVar v)

これは間違っている.
なぜなら, 一つ目の `runST` のコンテキスト内で生成した変更可能な参照を, 二番目の `runST` で再び使おうとしているからである.
言い換えれば, `v` の場合, `(forall s. ST s a) -> a` の結果の型 `a` は `STRef s String` で無いかもしれない.
しかし, rank-2 type はまさにそれを保証してくれるのだ!
なぜなら, 引数の型 `(forall s. ST s a)` の `s` は多相型でなければならず, 全ての `s` に対して, 同じ型 `a` を返さなければならない.
結果の型 `a` は `s` に依存することはできないのである.
従って, この望ましくないコード片は上記のエラーを含み, コンパイルエラーとなる.

これは, STモナドのオリジナル論文で, より詳細な解説を見ることができる.
