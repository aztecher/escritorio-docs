==================================
Stateモナドを構造からわかりやすく
==================================

対象
=========

* HaskellとかPureScriptみたいな関数指向言語をさわってみたことがある
* Haskellっぽい記法がちょっとわかる
* モナドを理解しようと頑張ったことがある
* カリー化の意味はわかる

用語
========

* `a`, `b`, `c`, `d` : 任意の型を指す(型変数). よく `Int` や `String` になる.
* `a -> b` : 関数. 型 `a` の値を入れると型 `b` の値を返す関数
* `(a, b)` : タプル. 型 `a` と型 `b` をセットにして一つの型にしたもの.
* `(a -> b) >>> (b -> c)` : 関数合成. `a -> c` になる.

Stateをつくる
================

状態(State)とはなにか
-----------------------

まぁ大体こんなもん

* 処理の「外」に持っていられる, 書き換え可能なデータセット
* 処理の連鎖の中で常に変化しながら伝搬していくデータ

状態と呼ばれるものは「常に参照可能」で「更新可能」である必要があるだろう.

状態を持つ関数
----------------

さて, ここに関数がある

.. code-block:: hs

    a -> b

この関数は, `a` 以外の外部データを持つことはない.
「関数が状態を持つ」というのは, 言い換えると「関数内で状態の値を参照したい」「状態を任意に書き換えたい」ということになる.

まぁつまりこんなかんじ.

.. code-block:: hs

    (a, s) -> (b, s)

`s` は状態(state)だ.
丁寧に読むと, 「型 `a` と `s` のペアを受け取って, 型 `b` と `s` のペアを返す」関数である.
つまりこの関数内では, 受け取った `s` の値を参照できて, 好きに変更した `s` の値を `b` と一緒に返せるということになる.

ここで, こんな関数も拾ってきた

.. code-block:: hs

    b -> c

これも同じように `s` を扱えるようにする

.. code-block:: hs

    (b, s) -> (c -> s)

この関数は明らかに先程の関数と合成できるね!

.. code-block:: hs

    (a, s) -> (b, s) >>> (b, s) -> (c, s) == (a, s) -> (c, s)

こんなふうに, 「 `s` をおまけでとり, `s` をおまけで返す」を繰り返すことで, 擬似的に状態を扱える関数を定義できた気分になるよね!

状態を持つ関数, だったもの
----------------------------

まず先程の関数. おもむろにカリー化してみましょう

.. code-block:: hs

    (a, s) -> (b, s)
    = a -> s -> (b, s)

さて, ここで関数の戻り値側に, ただの別名を付けてみる.

.. code-block:: hs

    a -> State b

おや?

おやおや???
-------------

.. code-block:: hs

    State b == (s -> (b, s))

この形, 見覚えありませんか?

まぁ, とりあえず置いときましょう.

同じ様に, もう一つの関数も書き換えて, 合成してみましょう.

.. code-block:: hs

    (b, s) -> (c, s)
    = b -> State c

    (a -> State b) >>> (b -> State c)

あれ?

合成できんやんけ!
-------------------

`>>>` は左の関数の戻り値を, 右の関数の引数に渡すだけのものなので,
`State b` と `b` の型が合わないので合成できない!! どうしよう???

じゃあ, 合成する演算子を定義してやればいいだろう.

再, 合成
-----------

`>=>` とかいう演算子を決めて, こんな感じで合成できるとする.

.. code-block:: hs

    (a -> State b) >=> (b -> State c) == (a -> State c)

うひょ〜合成できたわ.
こんな演算子もってくるのずるい? 知らんがな. できるからええねん.
まぁ, 真面目な話, 実際にやってることは最初にやっていた状態を付加したタプルの連結とかそんなのと同じ事だよね.
ただ, Stateとかいう名前つけたせいで合成できなくなって `>=>` とか考えたわけだったんだけど.

まぁ, という話が実は, 「 `モナドの全て` 」なのよ

モナド
==========

モナドは世の中でいろんな説明のされ方をされてるし, それらは往々にして正しいんだけど, 今回は以下のように説明するとしましょう. つまり,

「モナドは, 特定の型をした関数がキレイに合成できる「性質」だよ」


突然のかけ算! そして「モノイド」
---------------------------------

* (*) という二項演算子がある
* (*) は `Int` と `Int` を取って, `Int` を返す

つまり, かけ算 `(*)` とは, 「２つの `Int` を合成して一つにするもの」といえる!

そしてかけ算には

* 単位元が存在する
* 右から演算しても, 左から演算しても同じ!

という素晴らしい性質がある.

これらの性質をもう少しちゃんと見ていこう.

さて, これらの性質つまり

1. 二項演算
2. 単位元が存在する.
3. どこから計算しても同じ. (右結合と左結合の結果が同じ)

これをすべて持った演算は「モノイド」と呼ばれている.
うっ...と思うかもだが, 単純に「性質を指す用語」程度に覚えておくといい.

再, 再, 関数合成
------------------

関数合成ってよく考えると, ２つの `(? -> ?)` と `(? -> ?)` をくっつけて, 一つの `(? -> ?)` になるように見えない?

見えるよね?

みえろ

「二つの関数を合成して一つにする」

さて, 関数３つの合成だけど, これって合成順番入れ替えても同じだよね.

`(a -> b) >>> { (b -> c) >>> (c -> d) }`
`{ (a -> b) >>> (b -> c) } >>> (c -> d)`

「どこから先に計算しても同じ結果になる」

最後, `a -> b` ばかり見てきたけど, `a -> a` とか `b -> b` とかいう関数もあるよね?

`(a -> a) >>> (a -> b) == (a -> b)`
`(a -> b) >>> (b -> b) == (a -> b)`

「右に掛けても左に掛けても結果が変わらない特別な関数, `id :: a -> a` 」

...おや?
......おやおや?
これって, 「モノイド」では?
「関数合成はモノイド」では??

さあ, Stateの出番だ
----------------------

「二つの謎関数を合成して一つにする」

`(a -> State b) >=> (b -> State c) == (a -> State c)`

「どこから先に合成しても同じ結果になる」

`(a -> State b) >=> { (b -> State c) >=> (c -> State d) }`
`{ (a -> State b) >=> (b -> State c) } >=> (c -> State d)`

「右に掛けても, 左に掛けても結果が変わらない特別な謎関数, `return :: a -> m a` 」

`(return :: a -> State a) >=> (a -> State b) == (a -> State b)`
`(a -> State b) >=> (return :: b -> State b) == (a -> State b)`

**おわかりいただけただろうか**

結局モナドとはなんぞや?
========================

「 `* -> m *` みたいな変な形の関数同士を合成して一つにできて, どこから先に合成しても結果が変わらなくて, 右から合成しても左から合成しても式が変化しない特別な関数が存在する」ものが, モナドである.

この説明が `State` でも `Maybe` でも `List` でも `Either` でも成り立つ.
ほんとだよ.

モナド入門の鬼門 `IO` を爆破せよ
===================================

そのまえに, `State` くんのことを思い出してあげよう.
`State` くんは, 「状態 `s` を受け取り内部で参照でき, かつ更新したものを返せる関数」に **別名をつけたもの** だったよね.

この `s` ってなんだろう.

`s` が `Int` ならカウンタみたいなものが作れるよね. いかにもな感じ.

今度は, `s` に `Console` を入れてみよう.
そうそれ, お前がいま叩いてるやつね.

「 `Console` を内部で参照でき, かつ更新して返せる関数」ということは, コンソールを参照して `read` や, コンソールを更新して `write` ができるということになりそうじゃね? ...なるんだけどさ!


じゃあ, `s` に `この世界の全て` を入れたら...?

それが `IO` である.
`IO` は `s` の内容が派手な, ただの `State` だったのである.
逆に, `IO` は `State` なのだから, **IOはただの関数である**

ただの関数が副作用を起こせるのは, **キミがそのプログラムを起動するときに, 無意識にこの世界の全てを引数に渡しているから** だったのだ!!

落ち穂拾い
===========

>>= とかあったよね?
-----------------------

今回見てきた演算子は, 

.. code-block:: hs

    (>=>) :: (a -> m b) -> (b -> m c) -> (a -> m c)

であったが, 色んな所で見かける演算子はいわゆるバインド

.. code-block:: hs

    (>>=) :: m a -> (a -> m b) -> m b

である. 実はこれはほとんど同じで,

.. code-block:: hs

    (a -> m b) >=> (b -> m c) == (a -> m c)
    a -> (m b >>= (b -> m c)) == a -> (m c)

演算子でつなぐ位置が違うだけなわけですわ
んでもって, 下のほうがよく使われるんですね.

なんでかというと, 二つを見比べるとわかるが, 「 `b -> m c` の関数のスコープ内に `a` が含まれている」んだな.
つまり, クロージャで左辺の引数まで参照できてしまうわけだ.
これが便利なときがとても多いから, バインドが主流になっているのである.

関数が合成できるだけでなんでそんなに騒いだの?
-----------------------------------------------

え? だって関数が合成できるからプログラム組めるんじゃん

結局のところモナドのメリット
------------------------------

色々言えるだろう.

1. 関数合成に任意の追加計算を含ませることができる.
2. プログラミング言語的観点で, `do` 記法が利用できる.

とかとか
実際, `do` 記法は「純粋関数の世界で手続き型の作法をエミュレートできる」という素晴らしいものである.

なにか問題でも?
-----------------

知ってる人は知っている以下の句

「モナドは単なる自己関手の圏におけるモノイド対象だよ. なにか問題でも?」

これも今ならだいぶわかるのではないだろうか.
すなわち, モナドの関数 `a -> m b` って, 「 `*` を受け取って, `m *` を返す関数 `m` 」みたいに表現することもできるわけなので.
ここで, `*` がどんな型であっても成り立つので, 「 `m` は関手である」というのが正しい. そして, Haskellでは対象は型しかないため, 関手は必然的に「型と関数の圏」の自己関手になる.

そんでもって, `m` を対象にするということは, 「関手の圏」の上の話になり, その `m` は先程モノイドであることを示した.

つまり全部まとめると,

「モナドは自己関手の圏上のモノイド対象」ということだ


